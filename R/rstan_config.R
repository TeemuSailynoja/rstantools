#' Configure system files for compiling Stan source code
#'
#' Creates or update package-specific system files to compile \code{.stan} files in \code{src/stan_files}.
#'
#' @template args-pkgdir
#' @details The Stan source files for the package should be stored in:
#' \itemize{
#'   \item \code{inst/stan/src} for \code{.stan} files containing instructions to build a \code{stanmodel} object.
#'   \item \code{inst/stan/include} for files to be included via the \code{#include "mylib.stan"} directive.
#'   \item \code{inst/stan/include} for a \code{license.stan} file.
#'   \item \code{inst/stan/include} for the \code{meta_header.hpp} file, to be used for directly interacting with the Stan C++ libraries.
#' }
#' @export
rstan_config <- function(pkgdir = ".") {
  pkgdir <- .check_pkgdir(pkgdir) # check if package root directory
  # get stan model files
  stan_files <- list.files(file.path(pkgdir, "inst", "stan"),
                           full.names = TRUE, pattern = "*[.]stan$")
  if(length(stan_files) != 0) {
    # convert all .stan files to .cc/.hpp pairs
    sapply(stan_files, .make_cc, pkgdir = pkgdir)
    # update package Makevars
    .add_Makevars(pkgdir)
    .add_Makevars(pkgdir, win = TRUE)
  } else {
    # no stan files, so get rid of Makevars
    file.remove(file.path(pkgdir, "src", c("Makevars", "Makevars.win")))
  }
  # remove any .cc/.hpp pairs with no corresponding .stan file
  all_files <- list.files(file.path(pkgdir, "src", "stan_files"),
                          full.names = TRUE, pattern = "*[.](cc|hpp|o)$")
  ## keep_files <- gsub(pattern = "(.*?)\\..*$",
  ##                    replacement = "\\1", basename(all_files)) %in%
  ##   gsub(pattern = "(.*?)\\..*$", replacement = "\\1",
  ##        basename(stan_files))
  rm_files <- !.basename_noext(all_files) %in% .basename_noext(stan_files)
  if(any(rm_files)) {
    file.remove(all_files[rm_files])
    # also remove src/stan_init.o to trigger recompile mechanism
    init_file <- file.path(pkgdir, "src", "stan_init.o")
    if(file.exists(init_file)) file.remove(init_file)
  }
  ## # remove any model-specific c++ files generated by rstantools
  ## .remove_stanfiles(pkgdir)
  ## # convert .stan files to .cc/.hpp pairs and put these in src/stan_files
  ## stan_files <- list.files(file.path(pkgdir, "inst", "stan"),
  ##                          full.names = TRUE, pattern = "*[.]stan$")
  ## if(length(stan_files) != 0) {
  ##   sapply(stan_files, .make_cc, pkgdir = pkgdir)
  ##   .add_Makevars(pkgdir)
  ##   .add_Makevars(pkgdir, win = TRUE)
  ## }
  ## .add_staninit(pkgdir) # add stan_init.cpp to trigger compile mechanism
  # update R/stanmodels.R with current set of models
  stanmodels <- .update_stanmodels(pkgdir)
  .add_stanfile(stanmodels, pkgdir, "R", "stanmodels.R")
}

#--- helper functions ----------------------------------------------------------

# file basename without extension
.basename_noext <- function(file_names) {
  gsub(pattern = "(.*?)\\..*$",
       replacement = "\\1", basename(file_names))
}

# remove all model-specific files autogeneratedy by rstantools
# these are:
# src/Makevars[.win]
# src/stan_files/*
.remove_stanfiles <- function(pkgdir) {
  # rm src/stan_files/*
  file.remove(list.files(file.path(pkgdir, "src", "stan_files"),
                         full.names = TRUE, recursive = TRUE))
  file.remove(list.files(file.path(pkgdir, "src", "stan_files"),
                         full.names = TRUE, recursive = TRUE,
                         include.dirs = TRUE))
  # rm stan files in src
  stan_files <- c("Makevars", "Makevars.win")
  stan_files <- file.path(pkgdir, "src", stan_files)
  for(sf in stan_files) {
    if(file.exists(sf) &&
       (readLines(sf, n = 1) == .rstantools_noedit(sf))) {
      file.remove(sf)
    }
  }
}

# init file required for Makevars to compile Stan cc/hpp files
.add_staninit <- function(pkgdir) {
  init_file <- readLines(.system_file("stan_init.cpp"))
  init_file <- gsub("RSTAN_PACKAGE_NAME", basename(pkgdir), init_file)
  curr_file <- file.path(pkgdir, "src", "stan_init.cpp")
  if(!file.exists(curr_file) ||
     !identical(init_file, readLines(curr_file))) {
    # only overwrite if necessary to avoid triggering recompile
    .add_stanfile(init_file, pkgdir, "src", "stan_init.cpp",
                  noedit = TRUE, msg = FALSE, warn = TRUE)
  }
}

# creates Makevars[.win] file with Stan-specific compile instructions
# namely, location of StanHeaders and BH libraries,
# and subfolder compile instructions.
.add_Makevars <- function(pkgdir, win = FALSE) {
  mkv_name <- paste0("Makevars", if(win) ".win" else "")
  makevars <- readLines(.system_file(mkv_name))
  # replace generic line "SOURCES = ..." with package-specific line
  src_line <- list.files(file.path(pkgdir, "inst", "stan"),
                         pattern = "*[.]stan$")
  if(length(src_line) > 0) {
    src_line <- gsub("[.]stan$", ".cc", file.path("stan_files", src_line))
    makevars[grep("^SOURCES", makevars)] <- paste0(c("SOURCES =", src_line),
                                                   collapse = " ")
  }
  .add_stanfile(makevars, pkgdir, "src", mkv_name,
                noedit = TRUE, msg = FALSE, warn = TRUE)
  ## invisible(makevars)
}

# create .cc/.hpp pair from .stan file
# the .hpp file contains the C++ level class definition of the given stanmodel
# the .cc file contains the module definition which Rcpp uses to construct
# the corresponding R ReferenceClass.
.make_cc <- function(file_name, pkgdir) {
  model_name <- sub("[.]stan$", "", basename(file_name)) # model name
  stan_path <- file.path(pkgdir, "src", "stan_files") # path to src/stan_files
  ## # path to temporary location: only overwrite .cc/.hpp files if they changed
  ## stan_tmpdir <- tempfile("rstantools_")
  ## dir.create(stan_tmpdir, recursive = TRUE)
  # create c++ code
  cppcode <- rstan::stanc_builder(file_name, allow_undefined = TRUE,
                                  obfuscate_model_name = FALSE)$cppcode
  cppcode <- sub("(class[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*: public prob_grad \\{)",
                 paste("#include <stan_meta_header.hpp>\n", "\\1"), cppcode)
  # get license file (if any)
  stan_license <- .read_license(dirname(file_name))
  .add_stanfile(file_lines = c(stan_license,
                               "#ifndef MODELS_HPP",
                               "#define MODELS_HPP",
                               "#define STAN__SERVICES__COMMAND_HPP",
                               "#include <rstan/rstaninc.hpp>",
                               cppcode, "#endif"),
                pkgdir = pkgdir,
                "src", "stan_files", paste0(model_name, ".hpp"),
                noedit = TRUE, msg = FALSE, warn = TRUE)
  # create stanmodel class definition header file in temporary directory
  # don't want to trigger recompile unless its necessary
  # first create in tmpdir then move, because .cc created by exposeClass
  # does not give readLines output, i.e., copies
  ## tmp_file <- file.path(stan_tmpdir, paste0(model_name, ".hpp"))
  ## cat(stan_license,
  ##     "#ifndef MODELS_HPP",
  ##     "#define MODELS_HPP",
  ##     "#define STAN__SERVICES__COMMAND_HPP",
  ##     "#include <rstan/rstaninc.hpp>",
  ##     cppcode, "#endif",
  ##     file = tmp_file,
  ##     sep = "\n")
  ## # overwrite in src/stan_files if necessary
  ## .move_file(file.path(stan_path, paste0(model_name, ".hpp")), tmp_file)
  # create Rcpp module exposing C++ class as R ReferenceClass
  ## tmp_file <- file.path(stan_tmpdir, paste0(model_name, ".cc"))
  suppressMessages({
    cpp_lines <-
      capture.output(Rcpp::exposeClass(class = paste0("model_", model_name),
                                       constructors = list(c("SEXP", "SEXP", "SEXP")),
                                       fields = character(),
                                       methods = c("call_sampler",
                                                   "param_names",
                                                   "param_names_oi",
                                                   "param_fnames_oi",
                                                   "param_dims",
                                                   "param_dims_oi",
                                                   "update_param_oi",
                                                   "param_oi_tidx",
                                                   "grad_log_prob",
                                                   "log_prob",
                                                   "unconstrain_pars",
                                                   "constrain_pars",
                                                   "num_pars_unconstrained",
                                                   "unconstrained_param_names",
                                                   "constrained_param_names"),
                                       file = stdout(),
                                       header = paste0('#include "', model_name, '.hpp"'),
                                       module = paste0("stan_fit4", model_name, "_mod"),
                                       CppClass = "rstan::stan_fit<stan_model, boost::random::ecuyer1988> ",
                                       Rfile = FALSE))
  })
  .add_stanfile(file_lines = cpp_lines,
                pkgdir = pkgdir,
                "src", "stan_files", paste0(model_name, ".cc"),
                noedit = TRUE, msg = FALSE, warn = TRUE)
  ## # overwrite in src/stan_files if necessary
  ## .move_file(file.path(stan_path, paste0(model_name, ".cc")), tmp_file)
  return(invisible(NULL))
}

# read license file (if any)
.read_license <- function(stan_path) {
  stan_license <- dir(stan_path,
                      pattern = "license[.]stan$", recursive = TRUE,
                      full.names = TRUE)
  if(length(stan_license) > 1) {
    stop("Multiple license.stan files detected.")
  } else if(length(stan_license) == 0) {
    stan_license <- NULL
  } else {
    stan_license <- readLines(stan_license)
  }
  stan_license
}

# rewrites stanmodels.R reflecting current list of stan files
.update_stanmodels <- function(pkgdir) {
  model_names <- list.files(file.path(pkgdir, "inst", "stan"),
                            pattern = "*.stan$")
  model_names <- gsub("[.]stan$", "", model_names)
  if(length(model_names) == 0) {
    stanmodels <- .rstantools_noedit("stanmodels.R")
  } else {
    stanmodels <- readLines(.system_file("stanmodels.R"))
    # lines for Rcpp::loadModule
    load_line <- grep("^# load each stan module$", stanmodels)
      load_module <- sapply(model_names, gsub,
                            pattern = "STAN_MODEL_NAME",
                            x = stanmodels[load_line+1],
                            USE.NAMES = FALSE)
    # line for stanmodels assignment
    model_names <- paste0("\"", model_names, "\"")
    model_names <- paste0(model_names, collapse = ", ")
    model_names <- paste0("c(", model_names, ")", collapse = "")
    model_line <- grep("^# names of stan models$", stanmodels)
      model_names <- gsub("\"STAN_MODEL_NAME\"", model_names,
                          stanmodels[model_line+1])
    # add new lines to stanmodels
    nlines <- length(stanmodels)
    stanmodels <- c(stanmodels[1:model_line],
                    model_names,
                    stanmodels[(model_line+2):load_line],
                    load_module,
                    stanmodels[(load_line+2):nlines])
  }
  stanmodels
}

# replace old_file by new_file if new_file != old_file, otherwise leave as-is.
# then, delete new_file
.move_file <- function(old_file, new_file) {
  if(!file.exists(old_file) ||
     (tools::md5sum(old_file) != tools::md5sum(new_file))) {
    # new_file != old_file
    file.copy(from = new_file, to = old_file, overwrite = TRUE)
  }
  file.remove(new_file)
}
