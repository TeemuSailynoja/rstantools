# rstan_config
# Copyright (C) 2018 Martin Lysy
#
# rstantools is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# rstantools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
#' Configure system files for compiling Stan source code
#'
#' Creates or update package-specific system files to compile \code{.stan} model files found in \code{inst/stan}.
#'
#' @template args-pkgdir
#' @details The Stan source files for the package should be stored in:
#' \itemize{
#'   \item \code{inst/stan} for \code{.stan} files containing instructions to build a \code{stanmodel} object.
#'   \item \code{inst/stan/any_subfolder} for files to be included via the \code{#include "/my_subfolder/mylib.stan"} directive.
#'   \item \code{inst/stan/any_subfolder} for a \code{license.stan} file.
#'   \item \code{inst/include} for the \code{stan_meta_header.hpp} file, to be used for directly interacting with the Stan C++ libraries.
#' }
#' @export
rstan_config <- function(pkgdir = ".") {
  pkgdir <- .check_pkgdir(pkgdir) # check if package root directory
  # get stan model files
  stan_files <- list.files(file.path(pkgdir, "inst", "stan"),
                           full.names = TRUE, pattern = "*[.]stan$")
  if(length(stan_files) != 0) {
    # convert all .stan files to .cc/.hpp pairs
    sapply(stan_files, .make_cc, pkgdir = pkgdir)
    # update package Makevars
    .add_Makevars(pkgdir)
    .add_Makevars(pkgdir, win = TRUE)
  } else {
    # no stan files, so get rid of Makevars
    mkv_files <- file.path(pkgdir, "src", c("Makevars", "Makevars.win"))
    mkv_files <- mkv_files[file.exists(mkv_files)]
    if(length(mkv_files) > 0) file.remove(mkv_files)
  }
  # remove any .cc/.hpp/.o triplets with no corresponding .stan file
  .remove_stanfiles(pkgdir)
  ## all_files <- list.files(file.path(pkgdir, "src"),
  ##                         full.names = TRUE, pattern = "*[.](cc|h|o)$")
  ## all_files <- all_files %in% file.
  ## rm_files <- gsub("^stan_", "", .basename_noext(all_files))
  ## rm_files <- !rm_files %in% .basename_noext(stan_files)
  ## if(any(rm_files)) {
  ##   file.remove(all_files[rm_files])
  ## }
  # register exported modules as native routines
  Rcpp::compileAttributes(pkgdir)
  # update R/stanmodels.R with current set of models
  stanmodels <- .update_stanmodels(pkgdir)
  .add_stanfile(stanmodels, pkgdir, "R", "stanmodels.R")
}

#--- helper functions ----------------------------------------------------------

# file basename without extension
.basename_noext <- function(file_names) {
  gsub(pattern = "(.*?)\\..*$",
       replacement = "\\1", basename(file_names))
}

# removes any Stan-generated files in src which don't correspond to a model in
# /inst/stan
.remove_stanfiles <- function(pkgdir) {
  # stan model files
  stan_files <- list.files(file.path(pkgdir, "inst", "stan"),
                           full.names = FALSE, pattern = "*[.]stan$")
  # all files in src
  all_files <- list.files(file.path(pkgdir, "src"), full.names = FALSE)
  # reduce to stan model files
  src_files <- all_files[grepl("*[.](cc|h)$", all_files)]
  src_files <- src_files[grepl("^stan_", src_files)]
  # make sure 1st line is "don't edit"
  src_line1 <- sapply(file.path(pkgdir, "src", src_files), readLines, n = 1)
  src_files <- src_files[(src_line1 == .rstantools_noedit("foo.h")) |
                         (src_line1 == .rstantools_noedit("foo.cc"))]
  # stan model names corresponding to inactive stan files
  rm_names <- gsub("^stan_", "", src_files)
  rm_names <- unique(gsub("[.](cc|h)$", "", rm_names))
  rm_names <- rm_names[!(rm_names %in% gsub("[.]stan$", "", stan_files))]
  if(length(rm_names) > 0) {
    # get all cc/h/o files in src corresponding to these models
    rm_files <- c(outer(paste0("stan_", rm_names),
                        c(".cc", ".h", ".o"), paste0))
    # and finally the files to remove
    rm_files <- all_files[all_files %in% rm_files]
    file.remove(file.path(pkgdir, "src", rm_files))
  }
}

# remove all model-specific files autogeneratedy by rstantools
# these are:
# src/Makevars[.win]
# src/stan_files/*
# DEPRECIATED
## .remove_stanfiles <- function(pkgdir) {
##   # rm src/stan_files/*
##   file.remove(list.files(file.path(pkgdir, "src", "stan_files"),
##                          full.names = TRUE, recursive = TRUE))
##   file.remove(list.files(file.path(pkgdir, "src", "stan_files"),
##                          full.names = TRUE, recursive = TRUE,
##                          include.dirs = TRUE))
##   # rm stan files in src
##   stan_files <- c("Makevars", "Makevars.win")
##   stan_files <- file.path(pkgdir, "src", stan_files)
##   for(sf in stan_files) {
##     if(file.exists(sf) &&
##        (readLines(sf, n = 1) == .rstantools_noedit(sf))) {
##       file.remove(sf)
##     }
##   }
## }

# init file required for Makevars to compile Stan cc/hpp files
# DEPRECIATED
## .add_staninit <- function(pkgdir) {
##   init_file <- readLines(.system_file("stan_init.cpp"))
##   init_file <- gsub("RSTAN_PACKAGE_NAME", basename(pkgdir), init_file)
##   curr_file <- file.path(pkgdir, "src", "stan_init.cpp")
##   if(!file.exists(curr_file) ||
##      !identical(init_file, readLines(curr_file))) {
##     # only overwrite if necessary to avoid triggering recompile
##     .add_stanfile(init_file, pkgdir, "src", "stan_init.cpp",
##                   noedit = TRUE, msg = FALSE, warn = TRUE)
##   }
## }

# creates Makevars[.win] file with Stan-specific compile instructions
# namely, location of StanHeaders and BH libraries,
# and subfolder compile instructions.
.add_Makevars <- function(pkgdir, win = FALSE) {
  mkv_name <- paste0("Makevars", if(win) ".win" else "")
  makevars <- readLines(.system_file(mkv_name))
  # replace generic line "SOURCES = ..." with package-specific line
  # not needed for compiling without src/stan_files subdirectory
  ## src_line <- list.files(file.path(pkgdir, "inst", "stan"),
  ##                        pattern = "*[.]stan$")
  ## if(length(src_line) > 0) {
  ##   src_line <- gsub("[.]stan$", ".cc", file.path("stan_files", src_line))
  ##   makevars[grep("^SOURCES", makevars)] <- paste0(c("SOURCES =", src_line),
  ##                                                  collapse = " ")
  ## }
  .add_stanfile(makevars, pkgdir, "src", mkv_name,
                noedit = TRUE, msg = FALSE, warn = TRUE)
  ## invisible(makevars)
}

# create .cc/.h pair from .stan file
# the .hpp file contains the C++ level class definition of the given stanmodel
# the .cc file contains the module definition which Rcpp uses to construct
# the corresponding R ReferenceClass.
.make_cc <- function(file_name, pkgdir) {
  model_name <- sub("[.]stan$", "", basename(file_name)) # model name
  ## path to src/stan_files
  ## stan_path <- file.path(pkgdir, "src", "stan_files")
  # create c++ code
  cppcode <- rstan::stanc_builder(file_name, allow_undefined = TRUE,
                                  obfuscate_model_name = FALSE)$cppcode
  cppcode <- sub("(class[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*: public prob_grad \\{)",
                 paste("#include <stan_meta_header.hpp>\n", "\\1"), cppcode)
  # get license file (if any)
  stan_license <- .read_license(dirname(file_name))
  .add_stanfile(file_lines = c(stan_license,
                               "#ifndef MODELS_HPP",
                               "#define MODELS_HPP",
                               "#define STAN__SERVICES__COMMAND_HPP",
                               "#include <rstan/rstaninc.hpp>",
                               cppcode, "#endif"),
                pkgdir = pkgdir,
                "src", paste0("stan_", model_name, ".h"),
                noedit = TRUE, msg = FALSE, warn = TRUE)
  # create Rcpp module exposing C++ class as R ReferenceClass
  suppressMessages({
    cpp_lines <-
      utils::capture.output(
               Rcpp::exposeClass(class = paste0("model_", model_name),
                                 constructors = list(c("SEXP", "SEXP", "SEXP")),
                                 fields = character(),
                                 methods = c("call_sampler",
                                             "param_names",
                                             "param_names_oi",
                                             "param_fnames_oi",
                                             "param_dims",
                                             "param_dims_oi",
                                             "update_param_oi",
                                             "param_oi_tidx",
                                             "grad_log_prob",
                                             "log_prob",
                                             "unconstrain_pars",
                                             "constrain_pars",
                                             "num_pars_unconstrained",
                                             "unconstrained_param_names",
                                             "constrained_param_names"),
                                 file = stdout(),
                                 header = paste0('#include "stan_',
                                                 model_name, '.h"'),
                                 module = paste0("stan_fit4",
                                                 model_name, "_mod"),
                                 CppClass = "rstan::stan_fit<stan_model, boost::random::ecuyer1988> ",
                                 Rfile = FALSE)
             )
  })
  .add_stanfile(file_lines = cpp_lines,
                pkgdir = pkgdir,
                "src", paste0("stan_", model_name, ".cc"),
                noedit = TRUE, msg = FALSE, warn = TRUE)
  return(invisible(NULL))
}

# read license file (if any)
.read_license <- function(stan_path) {
  stan_license <- dir(stan_path,
                      pattern = "license[.]stan$", recursive = TRUE,
                      full.names = TRUE)
  if(length(stan_license) > 1) {
    stop("Multiple license.stan files detected.")
  } else if(length(stan_license) == 0) {
    stan_license <- NULL
  } else {
    stan_license <- readLines(stan_license)
  }
  stan_license
}

# rewrites stanmodels.R reflecting current list of stan files
.update_stanmodels <- function(pkgdir) {
  model_names <- list.files(file.path(pkgdir, "inst", "stan"),
                            pattern = "*.stan$")
  model_names <- gsub("[.]stan$", "", model_names)
  if(length(model_names) == 0) {
    stanmodels <- .rstantools_noedit("stanmodels.R")
  } else {
    stanmodels <- readLines(.system_file("stanmodels.R"))
    # lines for Rcpp::loadModule
    load_line <- grep("^# load each stan module$", stanmodels)
      load_module <- sapply(model_names, gsub,
                            pattern = "STAN_MODEL_NAME",
                            x = stanmodels[load_line+1],
                            USE.NAMES = FALSE)
    # line for stanmodels assignment
    model_names <- paste0("\"", model_names, "\"")
    model_names <- paste0(model_names, collapse = ", ")
    model_names <- paste0("c(", model_names, ")", collapse = "")
    model_line <- grep("^# names of stan models$", stanmodels)
      model_names <- gsub("\"STAN_MODEL_NAME\"", model_names,
                          stanmodels[model_line+1])
    # add new lines to stanmodels
    nlines <- length(stanmodels)
    stanmodels <- c(stanmodels[1:model_line],
                    model_names,
                    stanmodels[(model_line+2):load_line],
                    load_module,
                    stanmodels[(load_line+2):nlines])
  }
  stanmodels
}

# replace old_file by new_file if new_file != old_file, otherwise leave as-is.
# then, delete new_file
# DEPRECIATED
## .move_file <- function(old_file, new_file) {
##   if(!file.exists(old_file) ||
##      (tools::md5sum(old_file) != tools::md5sum(new_file))) {
##     # new_file != old_file
##     file.copy(from = new_file, to = old_file, overwrite = TRUE)
##   }
##   file.remove(new_file)
## }
